# Confidential Key Derivation

It is a very powerful primitive to allow any app running inside a TEE (Intel
TDX) to have a deterministically derived key that is unique to the app and not
specific to the TEE. The app can derive the same key even if it runs on a
different TEE. To obtain the key, the app can request a key to the MPC contract
on-chain, by submitting proof that it is running inside a TEE.

## Naming conventions

- *CKG*: confidential key generation
- *app*: TEE app calling the *CKG* functionality
- *operator*: entity owning the TEE-enabled hardware executing *app*
- $\texttt{opk}$: *operator*'s public key used to interact with our smart
  contract
- *developer*: the developer of the *app*
- $`\texttt{app\_id}`$: unique and verifiable identifier for the *app*
- $`\texttt{attestation}`$: the remote attestation report, which is a
cryptographic proof that *app* is running inside a genuine TEE. It includes
$\texttt{quote}$, $\texttt{MRTD}$, $\texttt{RTMR0}$, $\texttt{RTMR1}$,
$\texttt{RTMR2}$, $\texttt{RTMR3}$, *event_log* and *report_data*
- $`(a,A=a \cdot G)`$: fresh key pair generated by *app*
- $`\texttt{gen\_app\_private\_key}(\texttt{app\_id}, \texttt{attestation}, A,
  \texttt{opk})`$: function inside MPC smart contract to generate a
  deterministic secret to be used by an application running inside a TEE

- *MPC network*: the set of MPC nodes currently running
- $`\texttt{msk}`$: master secret key of the *MPC network*, which does not
  change over time
- $`s`$: the key obtained by *app*
- *DKG*: distributed key generation

## Requirements

- $`s`$ must be deterministic as a function of $`\texttt{app\_id}`$ and only
  known by *app*
- No single node in the *MPC network* should be capable of computing $`s`$. This
avoids key leakage in the case a single TEE is compromised
- $`\texttt{app\_id}`$ must be a unique deterministic value tied to *app* and
the attestation runtime measurements. It should not be forgeable by any other
app

## Security Assumptions

- The *operator* is not trusted, but its TEE-enabled hardware is considered
  secure
- MPC nodes running in TEE: All are trusted and execute the protocol honestly.
Liveness and correctness depend on this assumption, while the secrecy of $`s`$
does not
- The *developer* guarantee's the *app* security, and that the intended
attestation measurements ensure the chain of trust inside the TEE is not broken.
If this is not true, then $`\texttt{app\_id}`$ might be forged by a different
*app*

## Algorithm Steps

- The *app* generates EC ElGammal key pair $`(a, A)`$ and creates a transaction
  on-chain that calls $`\texttt{gen\_app\_private\_key}`$ with parameters
  $`\texttt{app\_id},\texttt{attestation},A,\texttt{opk}`$.
- $`\texttt{gen\_app\_private\_key}`$ verifies *app* is correctly being executed
  inside a TEE and computes $`\texttt{app\_id}`$:
  - verify that $`\texttt{attestation}`$ is valid. This process follows closely
  the one described in [dstack
  doc](https://github.com/Dstack-TEE/dstack/blob/6b77340cf530b4532c5815039a74bb3a60302378/attestation.md)
  - verify the *event_log* contains the *app* docker image digest
    $`\texttt{app\_image\_hash}`$
  - (optional) verify the value of $`\texttt{MRTD}`$ is inside a set of safe
    values
  - verify that $`A`$ and $\texttt{opk}$ are part of *report_data*
  - $`\texttt{app\_id} \gets \texttt{SHA256}(\texttt{RTMR0} ||\texttt{RTMR1}
    ||\texttt{RTMR2} || \texttt{RTMR3} || \texttt{app\_image\_hash})`$
  
- $`\texttt{gen\_app\_private\_key}`$ creates a transaction on-chain with a
  *CKG* request with parameters $`\texttt{app\_id}`$ and $`A`$
- When the *MPC Network* receives a new *CKG* request with parameters
$`\texttt{app\_id}`$ and $`A`$, this request is sent to all nodes and the key
generation process starts. Let $`x_i`$ be the private secret shares of the MPC
nodes, $`λ_i`$ the Lagrange coefficients and $`H`$ is a cryptographically secure
hash to curve function from
[rfc9380](https://datatracker.ietf.org/doc/rfc9380/). Notice that $`msk = x_1
\cdot λ_1 + \ldots + x_n \cdot λ_n`$ as a result of the *DKG*. The steps of the
generation process follow:
  - Node $`i\in \{1, \ldots n\}`$ receives $`(\texttt{app\_id}, A)`$ and
    computes:
    - $`y_i  \gets^{\$} \mathbb{Z}_q`$
    - $`Y_i \gets y_i \cdot G`$
    - $`S_i = x_i \cdot H(\texttt{app\_id})`$
    - $`C_i =  S_i + y_i \cdot A`$
  - Node $`i`$ sends $`(Y_i, C_i)`$ to the *MPC network* coordinator
  - The coordinator computes:
    - $`R \gets λ_1 \cdot Y_1 + \ldots + λ_n \cdot Y_n`$
    - $`S \gets λ_1 \cdot C_1 + \ldots + λ_n \cdot C_n = λ_1 \cdot S_1 + \ldots +
    λ_n \cdot S_n + ({y_1 \cdot λ_1 + \ldots + y_n \cdot λ_n }) \cdot A =
    \texttt{msk} \cdot H(\texttt{app\_id}) + a \cdot R`$
    - $`\texttt{es} \gets (R, S) `$
  - Coordinator sends $`\texttt{es}`$ to *app* on-chain
- *app* obtains $`\texttt{es} = (R, S)`$ and computes $`s \gets S + (- a) \cdot
    R = \texttt{msk} \cdot H(\texttt{app\_id})`$
