# Confidential Key Derivation

It is a very powerful primitive to allow any app running inside an TEE (Intel
TDX) to have a deterministically derived key that is unique to the app and not
specific to the TEE. The app can derive the same key even if it runs on a
different TEE. To obtain the key, the app can request a key to the MPC contract
on-chain, by submitting proof that it is running inside a TEE.

## Naming conventions

- *app*: TEE app calling the functionality
- $\text{app\_id}$: unique and verifiable identifier for the *app*
- $\text{attestation}$: a cryptographic proof that *app* is running inside TEE
- $(a,A=a \cdot G)$: fresh keypair generated by *app*
- $\text{gen\_app\_private\_key}(\text{app\_id}, \text{attestation}, A)$:
  function inside MPC smart contract to generate a deterministic secret to be
  used by an application running inside a TEE
- *operator*: entity owning the TEE-enabled hardware executing *app*
- *developer*: the developer of the *app*
- *MPC network*: the set of MPC nodes currently running
- $\text{msk}$: master secret key of the *MPC network*, which does not change
  over time
- $s$: the key obtained by *app*

## Requirements

- $s$ must be deterministic and only known by *app*
- No single node in the *MPC network* should be capable of computing $s$. This
avoids key leakage in the case a single TEE is compromised
- $\text{app\_id}$ must be a unique deterministic value tied to *app* and the
attestation runtime measurements. It should not be forgeable by any other app

## Security Assumptions

- The *operator* is not trusted, but its TEE-enabled hardware is considered
  secure
- MPC nodes running in TEE: All are trusted and execute the protocol honestly.
Liveness and correctness depend on this, while the secrecy of $s$ does not

## Algorithm Steps

- The *app* generates EC ElGammal keypair $(a, A)$ and creates a transaction
  onchain that calls $\text{gen\_app\_private\_key}$ with parameters
  $\text{app\_id},\text{attestation},A$.
- $\text{gen\_app\_private\_key}$ verifies *app* is correctly being executed
  inside a TEE using $\text{app\_id}$ and $\text{attestation}$.
- $\text{gen\_app\_private\_key}$ creates a transaction onchain with a key
  generation request that contains $\text{app\_id}$ and $A$
- The *MPC network* reads the request, computes $s$ implicitly, and creates a
  transaction with the response $\text{es} = \text{ThrEnc}(s, A)$ onchain
- The *app* obtains $\text{es}$ from the blockchain, decrypts $\text{es}$
  using its key $a$ and obtains $s$

## $\text{app\_id}$ computation and verification (WIP)

The app developer controls the Near account with public key *npk*. The
$\text{attestation}$ includes quote, MRTD, RTMR0, RTMR1, RTMR2, RTMR3,
*event_log*, *report_data*. *report_data* should contain $A$, *npk* and the
public key *opk* of *operator* Near account. The *developer* Near account
publishes onchain the set of values MRTD+RTMR0+RTMR1+RTMR2 which are considered
safe. $\text{gen\_app\_private\_key}$ executes the following:

- obtain the *opk* from report_data
- verify the value MRTD+RTMR0+RTMR1+RTMR2 sent by the *app* are in the set of
  safe values published by the app developer
- verify the values in $\text{attestation}$ are valid
- verify the *event_log* contains the *app* docker image hash
  $\text{app\_image\_hash}$
- verify $A$ and *opk* are part of REPORTDATA
- $\text{app\_id} \gets \text{SHA256}(\text{npk} ||
  \text{app\_image\_hash})$

## Computation of $s$ by *MPC Network*

When the *MPC Network* receives a new confidential key request which includes
$\text{app\_id}$ and $A$, this request is sent to all nodes and the key generation
process starts. Let $x_i$ be the private secret shares of the MPC nodes, $λ_i$
the Lagrange coefficients and $H$ is a cryptographically secure hash to curve
function from [rfc9380](https://datatracker.ietf.org/doc/rfc9380/). Notice that
$msk = x_1 \cdot λ_1 + \ldots + x_n \cdot λ_n$ as a result of the DKG.

### Generation steps

- Node $i\in \{1, \ldots n\}$ receives $(\text{app\_id}, A)$ and computes:
  - $y_i  \gets^{\$} \mathbb{Z}_q; Y_i \gets y_i \cdot G$
  - $S_i = x_i \cdot H(\text{app\_id})$
  - $C_i =  S_i + y_i \cdot A$
- Node $i$ sends $(Y_i, C_i)$ to the *MPC network* coordinator
- The coordinator computes:
  - $R \gets λ_1 \cdot Y_1 + \ldots + λ_n \cdot Y_n$
  - $S \gets λ_1 \cdot C_1 + \ldots + λ_n \cdot C_n = λ_1 \cdot S_1 + \ldots +
  λ_n \cdot S_n + ({y_1 \cdot λ_1 + \ldots + y_n \cdot λ_n }) \cdot A =
  \text{msk} \cdot H(\text{app\_id}) + a \cdot R$
  - $\text{es} \gets (R, S) $
- Coordinator sends $\text{es}$ to *app* onchain
- *app* obtains $\text{es} = (R, S)$ and computes $s \gets S + (- a) \cdot R =
  \text{msk} \cdot H(\text{app\_id})$
