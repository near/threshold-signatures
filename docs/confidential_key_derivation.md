# Confidential Key Derivation

It is a very powerful primitive to allow any app running inside an TEE (Intel
TDX) to have a deterministically derived key that is unique to the app and not
specific to the TEE. The app can derive the same key even if it runs on a
different TEE. To obtain the key, the app can request a key to the MPC contract
on-chain, by submitting proof that it is running inside a TEE.

## Naming conventions

- *app*: TEE app calling the functionality
- $`\texttt{app\_id}`$: unique and verifiable identifier for the *app*
- $`\texttt{attestation}`$: a cryptographic proof that *app* is running inside
  TEE
- $`(a,A=a \cdot G)`$: fresh keypair generated by *app*
- $`\texttt{gen\_app\_private\_key}(\texttt{app\_id}, \texttt{attestation},
  A)`$: function inside MPC smart contract to generate a deterministic secret to
  be used by an application running inside a TEE
- *operator*: entity owning the TEE-enabled hardware executing *app*
- *developer*: the developer of the *app*
- *MPC network*: the set of MPC nodes currently running
- $`\texttt{msk}`$: master secret key of the *MPC network*, which does not
  change over time
- $`s`$: the key obtained by *app*

## Requirements

- $`s`$ must be deterministic and only known by *app*
- No single node in the *MPC network* should be capable of computing $`s`$. This
avoids key leakage in the case a single TEE is compromised
- $`\texttt{app\_id}`$ must be a unique deterministic value tied to *app* and
the attestation runtime measurements. It should not be forgeable by any other
app

## Security Assumptions

- The *operator* is not trusted, but its TEE-enabled hardware is considered
  secure
- MPC nodes running in TEE: All are trusted and execute the protocol honestly.
Liveness and correctness depend on this, while the secrecy of $`s`$ does not

## Algorithm Steps

- The *app* generates EC ElGammal keypair $`(a, A)`$ and creates a transaction
  onchain that calls $`\texttt{gen\_app\_private\_key}`$ with parameters
  $`\texttt{app\_id},\texttt{attestation},A`$.
- $`\texttt{gen\_app\_private\_key}`$ verifies *app* is correctly being executed
  inside a TEE using $`\texttt{app\_id}$ and $\texttt{attestation}`$.
- $`\texttt{gen\_app\_private\_key}`$ creates a transaction onchain with a key
  generation request that contains $`\texttt{app\_id}$ and $A`$
- The *MPC network* reads the request, computes $`s`$ implicitly, and creates a
  transaction with the response $`\texttt{es} = \texttt{ThrEnc}(s, A)`$ onchain
- The *app* obtains $`\texttt{es}$ from the blockchain, decrypts $\texttt{es}`$
  using its key $`a$ and obtains $s`$

## $`\texttt{app\_id}`$ computation and verification (WIP)

The app developer controls the Near account with public key *npk*. The
$`\texttt{attestation}`$ includes quote, MRTD, RTMR0, RTMR1, RTMR2, RTMR3,
*event_log*, *report_data*. *report_data* should contain $`A`$, *npk* and the
public key *opk* of *operator* Near account. The *developer* Near account
publishes onchain the set of values MRTD+RTMR0+RTMR1+RTMR2 which are considered
safe. $`\texttt{gen\_app\_private\_key}`$ executes the following:

- obtain the *opk* from report_data
- verify the value MRTD+RTMR0+RTMR1+RTMR2 sent by the *app* are in the set of
  safe values published by the app developer
- verify the values in $`\texttt{attestation}`$ are valid
- verify the *event_log* contains the *app* docker image hash
  $`\texttt{app\_image\_hash}`$
- verify $`A`$ and *opk* are part of REPORTDATA
- $\texttt{app\_id} \gets \texttt{SHA256}(\texttt{npk} ||
  \texttt{app\_image\_hash})$

## Computation of $`s`$ by *MPC Network*

When the *MPC Network* receives a new confidential key request which includes
$`\texttt{app\_id}`$ and $`A`$, this request is sent to all nodes and the key
generation process starts. Let $`x_i`$ be the private secret shares of the MPC
nodes, $`λ_i`$ the Lagrange coefficients and $`H`$ is a cryptographically secure
hash to curve function from
[rfc9380](https://datatracker.ietf.org/doc/rfc9380/). Notice that $`msk = x_1
\cdot λ_1 + \ldots + x_n \cdot λ_n`$ as a result of the DKG.

### Generation steps

- Node $`i\in \{1, \ldots n\}`$ receives $`(\texttt{app\_id}, A)`$ and computes:
  - $`y_i  \gets^{\$} \mathbb{Z}_q; Y_i \gets y_i \cdot G`$
  - $`S_i = x_i \cdot H(\texttt{app\_id})`$
  - $`C_i =  S_i + y_i \cdot A`$
- Node $`i`$ sends $`(Y_i, C_i)`$ to the *MPC network* coordinator
- The coordinator computes:
  - $`R \gets λ_1 \cdot Y_1 + \ldots + λ_n \cdot Y_n`$
  - $`S \gets λ_1 \cdot C_1 + \ldots + λ_n \cdot C_n = λ_1 \cdot S_1 + \ldots +
  λ_n \cdot S_n + ({y_1 \cdot λ_1 + \ldots + y_n \cdot λ_n }) \cdot A =
  \texttt{msk} \cdot H(\texttt{app\_id}) + a \cdot R`$
  - $`\texttt{es} \gets (R, S) `$
- Coordinator sends $`\texttt{es}`$ to *app* onchain
- *app* obtains $`\texttt{es} = (R, S)`$ and computes $`s \gets S + (- a) \cdot
  R = \texttt{msk} \cdot H(\texttt{app\_id})`$
